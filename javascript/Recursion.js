// recursion : 하나의 함수가 자신을 다시 호출하여 반복되는 작업을 수행하는 함수

// 반복문과 재귀함수 차이
// 1. 재귀함수가 반복무보다 가독성이 더 좋다.
// 2. 재귀함수가 기본적으로 스택 메모리를 사용하는데 재귀의 깊이가 깊어졌을 때
//    stack overflow가 발생하면서 프로그램이 비정상적으로 종료될 수 있다.
//    또한 함수가 호출되고 종료될 때 스택 프레임을 구성하고 해제하는 과정에서 반복문보다 오버헤드가 든다.
// stack overflow 란
// - 함수를 호출하면 함수의 매개변수, 지역번수, 리턴 값, 함수 종료 후 돌아가는 위치가 스택 메모리에 함께 저장된다.
// 재귀함수를 쓰게 되면, 함수를 반복적으로 호출하므로 스택 메모리에 쌓이게 된다. 함수 호출횟수가 많아지면 스택 메모리를 초과한다.
// 그러나 일반적인 반복문을 사용하면 지역 변수들이 호출될 때마다 한번만 할당하기 때문에 이러한 비효율이 발생 안한다.

// 가독성도 좋고 스택 메모리도 성능 좋게 하기 위한 재귀함수의 단점을 보완한
// tail call recursion (꼬리 재귀)

// 정리하자면
// 재귀함수를 실행하는 중간에 다시 재귀함수가 호출되면, 재귀함수의 복사본을 하나 더 만들어서 복사본을 실행하게 됩니다.
// 재귀 호출은 내부적으로 스택 메모리를 통해 실행된다.
// 함수는 활성 레코드에 관련 정보를 저장하는데, 이 활성 레코드들이 스택 메모리에 순서대로 저장된 뒤 차례로 POP(제거) 된다.
// 이 과정에서 문맥 교환(context switch) 현상이 발생하기 때문에 재귀호출이 다른 방법에 비해 시간 복잡도가 늘어난다.
// 또한 재귀 함수를 호출할 때마다 변수가 새로 선언되기 때문에 재귀 함수를 지나치게 사용하면 메모리 부족 현상이 발생할 수 있다.
// 그래서 재귀 함수를 사용할 때 함수를 너무 많이 호출해야 한다면 사용하지 않는 것이 좋다.

// 꼬리재귀
// 일반 재귀함수의 경우 리턴되는 함수의 값을 받아 연산을 다시 하고 그 값을 리턴하는 방식을 취한다.
// 함수가 호출된 위치 즉, 활성 레코드를 기억해야만 하기 때문에 성능 저하 문제나 메모리 문제가 생긴다.
// 꼬리재귀는 위의 문제를 해결 할 수 있는데, 코드 상에서 해결하는 것이 아니라 컴파일러가 꼬리 재귀를 인식하고
//  코드를 최적화하면서 재귀 호출이 가진 문제점을 해결한다.
// 컴파일러는 꼬리재귀로 작성된 코드를 인식해서 반복문으로 바꿔준다. 즉, 겉모습만 재귀함수를 사용한 것이지 반복문을 사용한 것으로 인식되어
// 재귀함수의 단점을 제거할 수 있다.
// 꼬리 재귀는 재귀 호출이 끝난 이후 현재 함수 블록 내에서 추가 연산을 할 필요가 없도록 구현하는 형태.
// 함수가 리턴된 후에 아무 작업도 하지 않도록 하는 것을 꼬리재귀. 꼬리재귀는 연산이 return 문 이전에 이루어지고 다음 함수 호출 시
//   파라미터를 통해 필요한 연산의 결과를 전달한다.

const recursive = (n) => {
  if (n === 1) return 1

  return n + recursive(n - 1)
}

// 재귀함수를 컴파일러가 해석한 코드
const compileRecursive = (n) => {
  if (n === 1) return 1

  const result = compileRecursive(n - 1)
  return n + result
}

// 꼬리재귀
const tailRecursive = (n, acc) => {
  if (n === 1) return acc

  return tailRecursive(n - 1, n + acc)
}

// 꼬리재귀함수를 컴파일러가 해석한 코드
const compileTailRecursive = (n, acc) => {
  while (n > 1) {
    acc = acc + n
    n = n - 1
  }

  return acc
}

console.log(compileRecursive(10))
console.log(compileTailRecursive(10, 1))
